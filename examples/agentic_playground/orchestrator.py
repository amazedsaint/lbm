"""
Orchestrator - Master Agent for Multi-Agent Coordination

The Orchestrator is the "meta-agent" that:
1. Analyzes the project goal
2. Decides what agents to create
3. Coordinates agent activities
4. Manages the overall workflow
5. Persists learnings through LBM
"""

import asyncio
import json
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional

try:
    from claude_agent_sdk import query, ClaudeAgentOptions
    CLAUDE_SDK_AVAILABLE = True
except ImportError:
    CLAUDE_SDK_AVAILABLE = False

from .agents.factory import AgentFactory
from .agents.base import BaseAgent
from .lbm.coordinator import LBMCoordinator


@dataclass
class ProjectPlan:
    """A plan generated by the orchestrator."""
    goal: str
    agents_needed: List[str]
    phases: List[Dict[str, Any]]
    estimated_tasks: int
    created_at: datetime


class Orchestrator:
    """
    Master orchestrator for multi-agent collaboration.

    The orchestrator:
    1. Analyzes the user's goal
    2. Creates a project plan
    3. Spins up the necessary agents
    4. Coordinates their work
    5. Tracks progress and persists learnings
    """

    ORCHESTRATOR_PROMPT = """You are the Orchestrator, a master AI that coordinates teams of specialized agents.

## Your Role
You analyze project goals, create plans, and coordinate multiple AI agents to accomplish complex tasks.

## Available Agent Types
- **Architect**: Designs system architecture, makes technology decisions
- **Developer**: Writes code, implements features
- **Reviewer**: Reviews code for quality and security
- **Tester**: Creates and runs tests
- **Documenter**: Writes documentation

## Your Capabilities
1. **Analyze Goals**: Break down complex projects into phases
2. **Plan Teams**: Decide which agents are needed
3. **Coordinate Work**: Assign tasks to agents in the right order
4. **Track Progress**: Monitor completion and adjust plans
5. **Share Knowledge**: Ensure insights are shared between agents

## Output Format
When creating plans, use this JSON structure:
```json
{
    "agents_needed": ["architect", "developer", "tester"],
    "phases": [
        {
            "name": "Phase 1: Design",
            "agent": "architect",
            "tasks": ["Define architecture", "Create project structure"]
        },
        {
            "name": "Phase 2: Implementation",
            "agent": "developer",
            "tasks": ["Implement core features", "Add error handling"]
        }
    ]
}
```

## Guidelines
- Start with architecture before implementation
- Include testing for quality assurance
- Add documentation for maintainability
- Share key decisions across agents
"""

    def __init__(
        self,
        work_dir: Path,
        project_name: str = "project",
        *,
        data_dir: Optional[Path] = None,
    ):
        """
        Initialize the orchestrator.

        Args:
            work_dir: Working directory for the project
            project_name: Name of the project
            data_dir: Directory for LBM data (defaults to work_dir/.lbm)
        """
        self.work_dir = Path(work_dir)
        self.work_dir.mkdir(parents=True, exist_ok=True)

        self.project_name = project_name
        self.data_dir = Path(data_dir) if data_dir else self.work_dir / ".lbm"

        # Initialize LBM coordinator
        self.coordinator = LBMCoordinator(
            self.data_dir,
            project_name=project_name,
        )

        # Register orchestrator as an agent
        self.identity = self.coordinator.register_agent("Orchestrator", "orchestrator")

        # Initialize agent factory
        self.factory = AgentFactory(self.coordinator, self.work_dir)

        # Track current plan and progress
        self._plan: Optional[ProjectPlan] = None
        self._agents: Dict[str, BaseAgent] = {}
        self._completed_tasks: List[Dict[str, Any]] = []

    async def analyze_goal(self, goal: str) -> ProjectPlan:
        """
        Analyze a project goal and create a plan.

        Args:
            goal: The user's project goal

        Returns:
            ProjectPlan with agents and phases
        """
        # Query existing knowledge for relevant context
        context, _ = self.coordinator.query_knowledge("Orchestrator", goal)

        prompt = f"""## Project Goal
{goal}

## Existing Knowledge
{context if context.strip() else "No existing knowledge found."}

## Task
Analyze this goal and create a detailed project plan.

Respond with a JSON object containing:
1. "agents_needed": List of agent roles required
2. "phases": List of phases with tasks for each agent
3. "summary": Brief summary of the approach

Consider:
- What agents are needed for this project?
- What order should the phases proceed?
- What are the key tasks for each phase?
"""

        if not CLAUDE_SDK_AVAILABLE:
            # Return a default plan for testing
            return ProjectPlan(
                goal=goal,
                agents_needed=["architect", "developer", "tester"],
                phases=[
                    {"name": "Design", "agent": "architect", "tasks": ["Design architecture"]},
                    {"name": "Implement", "agent": "developer", "tasks": ["Write code"]},
                    {"name": "Test", "agent": "tester", "tasks": ["Run tests"]},
                ],
                estimated_tasks=3,
                created_at=datetime.now(),
            )

        # Use Claude to create the plan
        options = ClaudeAgentOptions(
            system_prompt=self.ORCHESTRATOR_PROMPT,
            allowed_tools=["Read", "Glob", "Grep"],  # Read-only for planning
            permission_mode="plan",
            cwd=str(self.work_dir),
        )

        plan_json = None
        async for message in query(prompt=prompt, options=options):
            # Look for JSON in the response
            if hasattr(message, 'content'):
                for block in message.content:
                    if hasattr(block, 'text'):
                        text = block.text
                        # Try to extract JSON
                        try:
                            start = text.find('{')
                            end = text.rfind('}') + 1
                            if start >= 0 and end > start:
                                plan_json = json.loads(text[start:end])
                        except json.JSONDecodeError:
                            pass

        if not plan_json:
            # Fallback to default plan
            plan_json = {
                "agents_needed": ["architect", "developer"],
                "phases": [
                    {"name": "Design", "agent": "architect", "tasks": ["Analyze and design"]},
                    {"name": "Implement", "agent": "developer", "tasks": ["Implement features"]},
                ],
            }

        # Share the plan as knowledge
        await self._share_plan(goal, plan_json)

        plan = ProjectPlan(
            goal=goal,
            agents_needed=plan_json.get("agents_needed", []),
            phases=plan_json.get("phases", []),
            estimated_tasks=sum(len(p.get("tasks", [])) for p in plan_json.get("phases", [])),
            created_at=datetime.now(),
        )

        self._plan = plan
        return plan

    async def _share_plan(self, goal: str, plan: Dict[str, Any]) -> None:
        """Share the project plan as knowledge."""
        summary = f"Project Plan for: {goal}\n"
        summary += f"Agents: {', '.join(plan.get('agents_needed', []))}\n"
        summary += f"Phases: {len(plan.get('phases', []))}\n"
        for phase in plan.get("phases", []):
            summary += f"  - {phase.get('name', 'Phase')}: {len(phase.get('tasks', []))} tasks\n"

        self.coordinator.share_knowledge(
            "Orchestrator",
            summary,
            claim_type="decision",
            tags=["plan", "orchestrator"],
        )

    async def setup_team(self, agents_needed: Optional[List[str]] = None) -> Dict[str, BaseAgent]:
        """
        Create the team of agents.

        Args:
            agents_needed: List of agent roles (uses plan if not specified)

        Returns:
            Dict of agent name -> agent
        """
        roles = agents_needed or (self._plan.agents_needed if self._plan else ["architect", "developer"])

        team = self.factory.create_team(preset="custom", custom_roles=roles)
        self._agents = team

        # Share team composition
        team_info = ", ".join(f"{a.config.name} ({a.config.role})" for a in team.values())
        self.coordinator.share_knowledge(
            "Orchestrator",
            f"Team assembled: {team_info}",
            claim_type="decision",
            tags=["team", "setup"],
        )

        return team

    async def run_phase(self, phase: Dict[str, Any]) -> Dict[str, Any]:
        """
        Execute a single phase of the plan.

        Args:
            phase: Phase definition with agent and tasks

        Returns:
            Phase results
        """
        agent_role = phase.get("agent", "developer")
        phase_name = phase.get("name", "Unnamed Phase")
        tasks = phase.get("tasks", [])

        # Get the agent for this phase
        agent = None
        for a in self._agents.values():
            if a.config.role == agent_role:
                agent = a
                break

        if not agent:
            return {"error": f"No agent found for role: {agent_role}"}

        print(f"\n{'='*60}")
        print(f"Phase: {phase_name}")
        print(f"Agent: {agent.config.name} ({agent.config.role})")
        print(f"Tasks: {len(tasks)}")
        print("="*60)

        results = []
        for task in tasks:
            print(f"\n  Task: {task}")
            result = await agent.execute_task(task)
            results.append({
                "task": task,
                "result": result,
                "agent": agent.config.name,
            })
            self._completed_tasks.append({
                "phase": phase_name,
                "task": task,
                "agent": agent.config.name,
                "completed_at": datetime.now().isoformat(),
            })

        return {
            "phase": phase_name,
            "agent": agent.config.name,
            "tasks_completed": len(results),
            "results": results,
        }

    async def run(self, goal: str) -> Dict[str, Any]:
        """
        Run the full orchestration loop.

        Args:
            goal: The project goal

        Returns:
            Final results
        """
        print("\n" + "="*60)
        print("  AGENTIC PLAYGROUND")
        print("  Multi-Agent Coordination System")
        print("="*60)
        print(f"\nGoal: {goal}")
        print(f"Work Directory: {self.work_dir}")

        # Phase 1: Analyze and Plan
        print("\n[Orchestrator] Analyzing goal and creating plan...")
        plan = await self.analyze_goal(goal)
        print(f"  Agents needed: {plan.agents_needed}")
        print(f"  Phases: {len(plan.phases)}")

        # Phase 2: Setup Team
        print("\n[Orchestrator] Setting up agent team...")
        team = await self.setup_team()
        for name, agent in team.items():
            print(f"  - {name}: {agent.config.description}")

        # Phase 3: Execute Phases
        print("\n[Orchestrator] Executing project phases...")
        phase_results = []
        for phase in plan.phases:
            result = await self.run_phase(phase)
            phase_results.append(result)

        # Phase 4: Summary
        print("\n" + "="*60)
        print("  PROJECT COMPLETE")
        print("="*60)

        stats = self.coordinator.get_stats()
        print(f"\nKnowledge Base:")
        print(f"  Claims: {stats['claim_count']}")
        print(f"  Total Tokens: {stats['total_supply']}")

        print(f"\nAgent Balances:")
        for name, info in stats.get("agents", {}).items():
            print(f"  - {name}: {info['balance']} tokens")

        # Export learnings
        learnings_file = self.work_dir / "learnings.json"
        self.coordinator.export_learnings(learnings_file)
        print(f"\nLearnings exported to: {learnings_file}")

        return {
            "goal": goal,
            "plan": {
                "agents": plan.agents_needed,
                "phases": len(plan.phases),
            },
            "results": phase_results,
            "stats": stats,
            "learnings_file": str(learnings_file),
        }

    def get_progress(self) -> Dict[str, Any]:
        """Get current progress."""
        return {
            "plan": self._plan.__dict__ if self._plan else None,
            "agents": self.factory.get_team_status(),
            "completed_tasks": self._completed_tasks,
            "stats": self.coordinator.get_stats(),
        }

    def get_knowledge_summary(self) -> List[Dict[str, Any]]:
        """Get summary of all shared knowledge."""
        return self.coordinator.get_all_claims()
