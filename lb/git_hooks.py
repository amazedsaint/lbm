"""Git hooks management for LBM GitHub integration.

This module provides utilities for managing git hooks that
enable automatic knowledge sync on commits and checkouts.
"""
from __future__ import annotations

import os
import stat
from pathlib import Path
from typing import List, Optional

from .logging_config import get_logger

logger = get_logger("lb.git_hooks")


# Hook templates
HOOK_TEMPLATES = {
    "post-commit": '''#!/bin/bash
# LBM auto-sync on commit
# Generated by 'lb github init'

# Check if lb command exists
if ! command -v lb &> /dev/null; then
    exit 0
fi

# Check if .lbm exists
if [ ! -d ".lbm" ]; then
    exit 0
fi

# Get commit info
COMMIT_MSG=$(git log -1 --pretty=%B 2>/dev/null)
FILES_CHANGED=$(git diff-tree --no-commit-id --name-only -r HEAD 2>/dev/null | tr '\\n' ',')

# Sync in background (don't block commit)
(lb github sync --commit "$COMMIT_MSG" --files "$FILES_CHANGED" 2>/dev/null &)
''',

    "post-checkout": '''#!/bin/bash
# LBM sync on checkout
# Generated by 'lb github init'

# Only run on branch checkout, not file checkout
if [ "$3" != "1" ]; then
    exit 0
fi

# Check if lb command exists
if ! command -v lb &> /dev/null; then
    exit 0
fi

# Check if .lbm exists
if [ ! -d ".lbm" ]; then
    exit 0
fi

# Sync in background
(lb github sync 2>/dev/null &)
''',

    "post-merge": '''#!/bin/bash
# LBM sync after merge
# Generated by 'lb github init'

# Check if lb command exists
if ! command -v lb &> /dev/null; then
    exit 0
fi

# Check if .lbm exists
if [ ! -d ".lbm" ]; then
    exit 0
fi

# Sync in background
(lb github sync 2>/dev/null &)
''',

    "post-rewrite": '''#!/bin/bash
# LBM sync after rebase/amend
# Generated by 'lb github init'

# Check if lb command exists
if ! command -v lb &> /dev/null; then
    exit 0
fi

# Check if .lbm exists
if [ ! -d ".lbm" ]; then
    exit 0
fi

# Sync in background
(lb github sync 2>/dev/null &)
''',
}

# Default hooks to install
DEFAULT_HOOKS = ["post-commit", "post-checkout"]


def install_hooks(
    repo_path: Path,
    hooks: Optional[List[str]] = None,
    force: bool = False,
) -> List[str]:
    """Install git hooks for LBM auto-sync.

    Creates hook scripts in .lbm/hooks/ and symlinks them to .git/hooks/.

    Args:
        repo_path: Path to git repository root
        hooks: List of hook names to install. Defaults to DEFAULT_HOOKS.
        force: If True, overwrite existing hooks.

    Returns:
        List of installed hook names

    Raises:
        ValueError: If repo_path is not a git repository
    """
    repo_path = Path(repo_path).resolve()
    git_dir = repo_path / ".git"

    if not git_dir.exists():
        raise ValueError(f"Not a git repository: {repo_path}")

    if hooks is None:
        hooks = DEFAULT_HOOKS

    # Validate hook names
    for hook in hooks:
        if hook not in HOOK_TEMPLATES:
            raise ValueError(f"Unknown hook: {hook}. Available: {list(HOOK_TEMPLATES.keys())}")

    # Create directories
    lbm_hooks_dir = repo_path / ".lbm" / "hooks"
    lbm_hooks_dir.mkdir(parents=True, exist_ok=True)

    git_hooks_dir = git_dir / "hooks"
    git_hooks_dir.mkdir(parents=True, exist_ok=True)

    installed = []

    for hook_name in hooks:
        # Write hook script to .lbm/hooks/
        hook_script = lbm_hooks_dir / hook_name
        with open(hook_script, "w") as f:
            f.write(HOOK_TEMPLATES[hook_name])

        # Make executable
        hook_script.chmod(hook_script.stat().st_mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)

        # Create symlink in .git/hooks/
        git_hook = git_hooks_dir / hook_name

        if git_hook.exists():
            if git_hook.is_symlink():
                # Remove old symlink
                git_hook.unlink()
            elif not force:
                logger.warning(f"Hook {hook_name} already exists, skipping (use --force to overwrite)")
                continue
            else:
                # Backup existing hook
                backup = git_hook.with_suffix(".backup")
                git_hook.rename(backup)
                logger.info(f"Backed up existing {hook_name} to {backup.name}")

        # Create relative symlink
        rel_path = os.path.relpath(hook_script, git_hooks_dir)
        git_hook.symlink_to(rel_path)
        installed.append(hook_name)
        logger.debug(f"Installed hook: {hook_name}")

    return installed


def uninstall_hooks(repo_path: Path, hooks: Optional[List[str]] = None) -> List[str]:
    """Uninstall LBM git hooks.

    Removes symlinks from .git/hooks/ and scripts from .lbm/hooks/.

    Args:
        repo_path: Path to git repository root
        hooks: List of hook names to uninstall. Defaults to all LBM hooks.

    Returns:
        List of uninstalled hook names
    """
    repo_path = Path(repo_path).resolve()
    git_hooks_dir = repo_path / ".git" / "hooks"
    lbm_hooks_dir = repo_path / ".lbm" / "hooks"

    if hooks is None:
        hooks = list(HOOK_TEMPLATES.keys())

    uninstalled = []

    for hook_name in hooks:
        # Remove symlink from .git/hooks/
        git_hook = git_hooks_dir / hook_name
        if git_hook.is_symlink():
            # Verify it points to our hook
            target = git_hook.resolve()
            if lbm_hooks_dir in target.parents or target.parent == lbm_hooks_dir:
                git_hook.unlink()
                uninstalled.append(hook_name)
                logger.debug(f"Uninstalled hook: {hook_name}")

                # Restore backup if exists
                backup = git_hook.with_suffix(".backup")
                if backup.exists():
                    backup.rename(git_hook)
                    logger.info(f"Restored backup for {hook_name}")

        # Remove script from .lbm/hooks/
        lbm_hook = lbm_hooks_dir / hook_name
        if lbm_hook.exists():
            lbm_hook.unlink()

    return uninstalled


def list_hooks(repo_path: Path) -> List[dict]:
    """List installed LBM git hooks.

    Args:
        repo_path: Path to git repository root

    Returns:
        List of hook info dicts with name, installed status, etc.
    """
    repo_path = Path(repo_path).resolve()
    git_hooks_dir = repo_path / ".git" / "hooks"
    lbm_hooks_dir = repo_path / ".lbm" / "hooks"

    hooks = []

    for hook_name in HOOK_TEMPLATES.keys():
        git_hook = git_hooks_dir / hook_name
        lbm_hook = lbm_hooks_dir / hook_name

        info = {
            "name": hook_name,
            "available": True,
            "installed": False,
            "is_lbm_hook": False,
        }

        if git_hook.exists():
            info["installed"] = True
            if git_hook.is_symlink():
                target = git_hook.resolve()
                info["is_lbm_hook"] = lbm_hooks_dir in target.parents or target.parent == lbm_hooks_dir
            else:
                info["is_lbm_hook"] = False
                info["note"] = "Custom hook (not managed by LBM)"

        hooks.append(info)

    return hooks


def verify_hooks(repo_path: Path) -> dict:
    """Verify LBM hooks are properly installed.

    Args:
        repo_path: Path to git repository root

    Returns:
        Verification result with status and any issues found
    """
    repo_path = Path(repo_path).resolve()

    result = {
        "ok": True,
        "issues": [],
        "hooks": {},
    }

    hooks = list_hooks(repo_path)

    for hook in hooks:
        if hook["name"] in DEFAULT_HOOKS:
            if not hook["installed"]:
                result["ok"] = False
                result["issues"].append(f"Hook {hook['name']} not installed")
            elif not hook["is_lbm_hook"]:
                result["ok"] = False
                result["issues"].append(f"Hook {hook['name']} exists but is not LBM-managed")

        result["hooks"][hook["name"]] = hook

    return result
